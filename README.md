# E-FRET 计算公式流程
## 超参数介绍
`a, b, c, d` 表示就是对应的单供体或者供体的不同滤片组通道得到的参数

`G因子，k因子`表示的显微镜本身较为固定的恒定参数

`expose_times`表示的是对应的曝光时间长度


##  计算流程介绍
* 我们输入的三个通道的图像，对应FRET三滤波片组得到的图像，分别是 
_IDA_ , _IDD_, _IAA_，三个都是单通道图像，也就是大于0的值
* 对于背景模板图像的计算，本质上就是使用三种通道图片背景的交集计算，而背景的阈值判断，使用直方图找到最大的一个灰度值 _maxvalue(hist(IDA))_ 乘上对应的一个阈值，拓宽对应的背景值
* 利用公式下面公式得到扣除背景的图，其中这里设计的是荧光图像三者通道的并集，也就是进行逐像素计算的时候，使用三通道有值的区域

_IDA,IDD,IAA-maxvalue(hist(IDA,IDD,IAA))_ （其中进行了利用阈值分类，保留大于0的值）

* 得到背景图图像 _BG_mould_，为1和0的值进行输出
* 得到只保留荧光像素的区域进行E效率和Rc浓度比计算
* 其中E的公式

_F = IDA - a * (IAA - c * IDD) - d * (IDD - b * IAA)_

_E = (F / (F + G * IDD + 1e-12)) * BG_mould_

_Rc = ((k * IAA) / (IDD + F / G + 1e-12)) * BG_mould_

* 计算完成上述公式，进行对应的图像结果输出

# 程序设计
## 1. 多线程cpu计算过程
+ 采用了阈值分割的方法，细胞区域存在一些像素点导致统计不到，FRET效率计算过程绝对强度没有意义，所以存在有效FRET被过滤掉
+ CPU多线程进行矩阵运算还是太慢了
使用多线程知识点，加速处理流程，其中对于以像素点为单位的多线程，发现点像素计算不如numpy的矩阵运算，后面将多线程改为以图片为单位的多线程计算过程

其中对于代码来说，伪彩图的生成耗费了大量的时间，建议可关闭

## 2. 基于GPU的pytorch加速处理FRET效率计算
### 2.1 细胞分割——使用cellpose进行加速